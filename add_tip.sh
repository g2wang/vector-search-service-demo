#!/bin/bash

curl -X POST http://localhost:3000/tip \
  -H "Content-Type: application/json" \
  -d '{"text": "This library provides anyhow::Error, a trait object based error type for easy idiomatic error handling in Rust applications.\n \n \n Details\n Use Result<T, anyhow::Error>, or equivalently anyhow::Result<T>, as the return type of any fallible function.\n \n Within the function, use ? to easily propagate any error that implements the std::error::Error trait.\n \n use anyhow::Result;\n \n fn get_cluster_info() -> Result<ClusterMap> {\n let config = std::fs::read_to_string(\"cluster.json\")?;\n let map: ClusterMap = serde_json::from_str(&config)?;\n Ok(map)\n }\n Attach context to help the person troubleshooting the error understand where things went wrong. A low-level error like “No such file or directory” can be annoying to debug without more context about what higher level step the application was in the middle of.\n \n use anyhow::{Context, Result};\n \n fn main() -> Result<()> {\n ...\n it.detach().context(\"Failed to detach the important thing\")?;\n \n let content = std::fs::read(path)\n .with_context(|| format!(\"Failed to read instrs from {}\", path))?;\n ...\n }\n Error: Failed to read instrs from ./path/to/instrs.json\n \n Caused by:\n No such file or directory (os error 2)\n Downcasting is supported and can be by value, by shared reference, or by mutable reference as needed.\n \n // If the error was caused by redaction, then return a\n // tombstone instead of the content.\n match root_cause.downcast_ref::<DataStoreError>() {\n Some(DataStoreError::Censored(_)) => Ok(Poll::Ready(REDACTED_CONTENT)),\n None => Err(error),\n }\n If using Rust ≥ 1.65, a backtrace is captured and printed with the error if the underlying error type does not already provide its own. In order to see backtraces, they must be enabled through the environment variables described in std::backtrace:\n \n If you want panics and errors to both have backtraces, set RUST_BACKTRACE=1;\n If you want only errors to have backtraces, set RUST_LIB_BACKTRACE=1;\n If you want only panics to have backtraces, set RUST_BACKTRACE=1 and RUST_LIB_BACKTRACE=0.\n Anyhow works with any error type that has an impl of std::error::Error, including ones defined in your crate. We do not bundle a derive(Error) macro but you can write the impls yourself or use a standalone macro like thiserror.\n \n use thiserror::Error;\n \n #[derive(Error, Debug)]\n pub enum FormatError {\n #[error(\"Invalid header (expected {expected:?}, got {found:?})\")]\n InvalidHeader {\n expected: String,\n found: String,\n },\n #[error(\"Missing attribute: {0}\")]\n MissingAttribute(String),\n }\n One-off error messages can be constructed using the anyhow! macro, which supports string interpolation and produces an anyhow::Error.\n \n return Err(anyhow!(\"Missing attribute: {}\", missing));\n A bail! macro is provided as a shorthand for the same early return.\n \n bail!(\"Missing attribute: {}\", missing);"}'
